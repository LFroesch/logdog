package detector

import (
	"fmt"
	"os"
	"path/filepath"
	"text/template"
)

type GoLanguage struct{}

func (g *GoLanguage) Name() string {
	return "Go"
}

func (g *GoLanguage) Detect(projectPath string) bool {
	goModPath := filepath.Join(projectPath, "go.mod")
	_, err := os.Stat(goModPath)
	return err == nil
}

func (g *GoLanguage) Install(projectPath string, config Config) error {
	fmt.Printf("DEBUG: Installing in %s\n", projectPath)

	// Create logdog directory structure
	logdogDir := filepath.Join(projectPath, "logdog")
	logsDir := filepath.Join(logdogDir, "logs")

	fmt.Printf("DEBUG: Creating %s\n", logsDir)
	if err := os.MkdirAll(logsDir, 0755); err != nil {
		return fmt.Errorf("failed to create logs directory: %w", err)
	}

	// Create internal/logdog directory
	internalDir := filepath.Join(projectPath, "internal", "logdog")
	fmt.Printf("DEBUG: Creating %s\n", internalDir)
	if err := os.MkdirAll(internalDir, 0755); err != nil {
		return fmt.Errorf("failed to create internal directory: %w", err)
	}

	// Generate logger.go
	loggerPath := filepath.Join(internalDir, "logger.go")
	fmt.Printf("DEBUG: Generating %s\n", loggerPath)
	if err := g.generateLogger(loggerPath, config); err != nil {
		return fmt.Errorf("failed to generate logger: %w", err)
	}

	// Generate README.md
	readmePath := filepath.Join(internalDir, "README.md")
	fmt.Printf("DEBUG: Generating %s\n", readmePath)
	if err := g.generateReadme(readmePath); err != nil {
		return fmt.Errorf("failed to generate README: %w", err)
	}

	fmt.Printf("DEBUG: Installation complete!\n")
	return nil
}

func (g *GoLanguage) generateReadme(outputPath string) error {
	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer file.Close()

	_, err = file.WriteString(readmeContent)
	return err
}

func (g *GoLanguage) GetLogPaths(projectPath string) []string {
	logsDir := filepath.Join(projectPath, "logdog", "logs")
	var paths []string

	filepath.Walk(logsDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return nil
		}
		if !info.IsDir() && filepath.Ext(path) == ".json" {
			paths = append(paths, path)
		}
		return nil
	})

	return paths
}

func (g *GoLanguage) generateLogger(outputPath string, config Config) error {
	tmpl := template.Must(template.New("logger").Parse(goLoggerTemplate))

	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer file.Close()

	data := struct {
		Config Config
	}{
		Config: config,
	}

	return tmpl.Execute(file, data)
}

const readmeContent = `# üêï Logdog

A TUI-based logging utility that makes structured logging simple and consistent across Go projects.

## What is Logdog?

Logdog is a terminal-based app that:
- **Detects** Go projects automatically
- **Generates** a logging package for your project
- **Creates** structured JSON logs with daily rotation
- **Provides** a user-friendly API for logging

## Quick Start

This logger was generated by Logdog. To use it in your code:

` + "```go" + `
import "your-project/internal/logdog"

func main() {
   // Simple message
   logdog.Info("Application started")
   
   // With additional data
   logdog.Info("User logged in", "user_id", 123, "username", "john")
   
   // Error with context
   logdog.Error("Database error", "table", "users", "operation", "insert")
}
` + "```" + `

## API Reference

### Basic Logging
` + "```go" + `
logdog.Debug("Debug message")
logdog.Info("Info message") 
logdog.Warn("Warning message")
logdog.Error("Error message")
` + "```" + `

### With Additional Data
` + "```go" + `
// Pass key-value pairs as arguments
logdog.Info("User action", 
   "user_id", 123,
   "action", "login",
   "ip", "192.168.1.1")
` + "```" + `

## Log Output

Logs are written as JSON to ` + "`logdog/logs/logdog-YYYY-MM-DD.json`" + `:

` + "```json" + `
{
 "timestamp": "2024-01-15 14:30:45",
 "level": "INFO",
 "message": "User logged in",
 "data": {
   "user_id": 123,
   "username": "john",
   "ip": "192.168.1.1"
 }
}
` + "```" + `

## File Structure

Your project now has:
` + "```" + `
your-project/
‚îú‚îÄ‚îÄ internal/logdog/
‚îÇ   ‚îú‚îÄ‚îÄ logger.go          # Generated logging package
‚îÇ   ‚îî‚îÄ‚îÄ README.md          # This documentation
‚îú‚îÄ‚îÄ logdog/
‚îÇ   ‚îî‚îÄ‚îÄ logs/
‚îÇ       ‚îî‚îÄ‚îÄ logdog-2024-01-15.json
‚îî‚îÄ‚îÄ go.mod
` + "```" + `

## Best Practices

1. **Use descriptive messages**: ` + "`\"User authentication failed\"`" + ` not ` + "`\"Error\"`" + `
2. **Include relevant context**: Always add user IDs, request IDs, etc.
3. **Use appropriate log levels**: 
  - ` + "`Debug`" + `: Development/troubleshooting info
  - ` + "`Info`" + `: Normal application events
  - ` + "`Warn`" + `: Unusual but handled situations
  - ` + "`Error`" + `: Actual problems that need attention
4. **Be consistent**: Use the same field names across your app

## Examples

### Web Server Logging
` + "```go" + `
// Request logging
logdog.Info("HTTP request", 
   "method", r.Method,
   "path", r.URL.Path,
   "user_id", userID,
   "ip", r.RemoteAddr)

// Error handling
if err != nil {
   logdog.Error("Database query failed", 
       "user_id", userID,
       "error", err.Error(),
       "query", "SELECT * FROM users")
   return
}

// Business events
logdog.Info("Order created",
   "user_id", userID,
   "order_id", order.ID,
   "total", order.Total)
` + "```" + `

### Background Jobs
` + "```go" + `
logdog.Info("Job started", "job_type", "email_sender", "batch_size", 100)

for _, email := range emails {
   if err := sendEmail(email); err != nil {
       logdog.Error("Email send failed", 
           "recipient", email.To,
           "template", email.Template,
           "error", err.Error())
       continue
   }
   logdog.Debug("Email sent", "recipient", email.To)
}

logdog.Info("Job completed", "sent", sentCount, "failed", failedCount)
` + "```" + `

---

Generated by Logdog - Simple structured logging for Go projects.`

const goLoggerTemplate = `package logdog

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sync"
	"time"
)

type LogLevel string

const (
	DEBUG LogLevel = "DEBUG"
	INFO  LogLevel = "INFO"
	WARN  LogLevel = "WARN"
	ERROR LogLevel = "ERROR"
)

type LogEntry struct {
	Timestamp string              ` + "`json:\"timestamp\"`" + `
	Level     LogLevel               ` + "`json:\"level\"`" + `
	Message   string                 ` + "`json:\"message\"`" + `
	Data      map[string]interface{} ` + "`json:\"data,omitempty\"`" + `
}

type Logger struct {
	mu       sync.Mutex
	logLevel LogLevel
	logDir   string
}

var defaultLogger *Logger
var once sync.Once

func init() {
	once.Do(func() {
		defaultLogger = &Logger{
			logLevel: INFO,
			logDir:   "logdog/logs",
		}
	})
}

func (l *Logger) log(level LogLevel, message string, data map[string]interface{}) {
	l.mu.Lock()
	defer l.mu.Unlock()

	entry := LogEntry{
	Timestamp: time.Now().Format("2006-01-02 15:04:05"), // Human readable format
	Level:     level,
	Message:   message,
	Data:      data,
	}

	// Get today's log file
	filename := fmt.Sprintf("logdog-%s.json", time.Now().Format("2006-01-02"))
	filepath := filepath.Join(l.logDir, filename)

	// Ensure directory exists
	if err := os.MkdirAll(l.logDir, 0755); err != nil {
		return
	}

	// Open file for appending
	file, err := os.OpenFile(filepath, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		return
	}
	defer file.Close()

	// Write JSON entry
	jsonData, _ := json.Marshal(entry)
	file.WriteString(string(jsonData) + "\n")
}

func buildData(args ...interface{}) map[string]interface{} {
	data := make(map[string]interface{})
	for i := 0; i < len(args); i += 2 {
		if i+1 < len(args) {
			if key, ok := args[i].(string); ok {
				data[key] = args[i+1]
			}
		}
	}
	return data
}

// Public API
func Error(message string, args ...interface{}) {
	defaultLogger.log(ERROR, message, buildData(args...))
}

func Warn(message string, args ...interface{}) {
	defaultLogger.log(WARN, message, buildData(args...))
}

func Info(message string, args ...interface{}) {
	defaultLogger.log(INFO, message, buildData(args...))
}

func Debug(message string, args ...interface{}) {
	defaultLogger.log(DEBUG, message, buildData(args...))
}
`
